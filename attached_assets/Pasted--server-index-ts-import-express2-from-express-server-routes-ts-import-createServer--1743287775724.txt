// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// server/scrum-knowledge.ts
var scrumValues = {
  values: ["Commitment", "Focus", "Openness", "Respect", "Courage"],
  description: "Successful use of Scrum depends on people becoming more proficient in living five values: Commitment, Focus, Openness, Respect, and Courage. The Scrum Team commits to achieving its goals and to supporting each other. Their primary focus is on the work of the Sprint to make the best possible progress toward these goals. The Scrum Team and its stakeholders are open about the work and the challenges. Scrum Team members respect each other to be capable, independent people, and are respected as such by the people with whom they work. The Scrum Team members have the courage to do the right thing, to work on tough problems."
};
var scrumTeam = {
  composition: "The Scrum Team consists of one Scrum Master, one Product Owner, and Developers. Within a Scrum Team, there are no sub-teams or hierarchies.",
  characteristics: [
    "Cross-functional, meaning the members have all the skills necessary to create value each Sprint",
    "Self-managing, meaning they internally decide who does what, when, and how",
    "Small enough to remain nimble and large enough to complete significant work within a Sprint, typically 10 or fewer people"
  ],
  roles: {
    developers: {
      name: "Developers",
      description: "The people in the Scrum Team that are committed to creating any aspect of a usable Increment each Sprint.",
      accountabilities: [
        "Creating a plan for the Sprint, the Sprint Backlog",
        "Instilling quality by adhering to a Definition of Done",
        "Adapting their plan each day toward the Sprint Goal",
        "Holding each other accountable as professionals"
      ]
    },
    productOwner: {
      name: "Product Owner",
      description: "The Product Owner is accountable for maximizing the value of the product resulting from work of the Scrum Team.",
      accountabilities: [
        "Developing and explicitly communicating the Product Goal",
        "Creating and clearly communicating Product Backlog items",
        "Ordering Product Backlog items",
        "Ensuring that the Product Backlog is transparent, visible and understood"
      ]
    },
    scrumMaster: {
      name: "Scrum Master",
      description: "The Scrum Master is accountable for establishing Scrum as defined in the Scrum Guide. They do this by helping everyone understand Scrum theory and practice, both within the Scrum Team and the organization.",
      accountabilities: {
        toTeam: [
          "Coaching the team members in self-management and cross-functionality",
          "Helping the Scrum Team focus on creating high-value Increments that meet the Definition of Done",
          "Causing the removal of impediments to the Scrum Team's progress",
          "Ensuring that all Scrum events take place and are positive, productive, and kept within the timebox"
        ],
        toProductOwner: [
          "Helping find techniques for effective Product Goal definition and Product Backlog management",
          "Helping the Scrum Team understand the need for clear and concise Product Backlog items",
          "Helping establish empirical product planning for a complex environment",
          "Facilitating stakeholder collaboration as requested or needed"
        ],
        toOrganization: [
          "Leading, training, and coaching the organization in its Scrum adoption",
          "Planning and advising Scrum implementations within the organization",
          "Helping employees and stakeholders understand and enact an empirical approach for complex work",
          "Removing barriers between stakeholders and Scrum Teams"
        ]
      }
    }
  }
};
var scrumEvents = {
  sprint: {
    name: "The Sprint",
    description: "Sprints are the heartbeat of Scrum, where ideas are turned into value. They are fixed length events of one month or less to create consistency. A new Sprint starts immediately after the conclusion of the previous Sprint.",
    rules: [
      "No changes are made that would endanger the Sprint Goal",
      "Quality does not decrease",
      "The Product Backlog is refined as needed",
      "Scope may be clarified and renegotiated with the Product Owner as more is learned"
    ],
    cancellation: "A Sprint could be cancelled if the Sprint Goal becomes obsolete. Only the Product Owner has the authority to cancel the Sprint."
  },
  sprintPlanning: {
    name: "Sprint Planning",
    description: "Sprint Planning initiates the Sprint by laying out the work to be performed for the Sprint. This resulting plan is created by the collaborative work of the entire Scrum Team.",
    topics: [
      "Topic One: Why is this Sprint valuable?",
      "Topic Two: What can be Done this Sprint?",
      "Topic Three: How will the chosen work get done?"
    ],
    outcome: "The Sprint Goal, the Product Backlog items selected for the Sprint, and the plan for delivering them are together referred to as the Sprint Backlog.",
    timebox: "Sprint Planning is timeboxed to a maximum of eight hours for a one-month Sprint. For shorter Sprints, the event is usually shorter."
  },
  dailyScrum: {
    name: "Daily Scrum",
    description: "The purpose of the Daily Scrum is to inspect progress toward the Sprint Goal and adapt the Sprint Backlog as necessary, adjusting the upcoming planned work.",
    structure: "The Developers can select whatever structure and techniques they want, as long as their Daily Scrum focuses on progress toward the Sprint Goal and produces an actionable plan for the next day of work.",
    benefits: "Daily Scrums improve communications, identify impediments, promote quick decision-making, and consequently eliminate the need for other meetings.",
    timebox: "The Daily Scrum is a 15-minute event for the Developers of the Scrum Team.",
    participation: "If the Product Owner or Scrum Master are actively working on items in the Sprint Backlog, they participate as Developers."
  },
  sprintReview: {
    name: "Sprint Review",
    description: "The purpose of the Sprint Review is to inspect the outcome of the Sprint and determine future adaptations. The Scrum Team presents the results of their work to key stakeholders and progress toward the Product Goal is discussed.",
    activities: [
      "The Scrum Team and stakeholders review what was accomplished in the Sprint and what has changed in their environment",
      "Attendees collaborate on what to do next",
      "The Product Backlog may also be adjusted to meet new opportunities"
    ],
    nature: "The Sprint Review is a working session and the Scrum Team should avoid limiting it to a presentation.",
    timebox: "The Sprint Review is timeboxed to a maximum of four hours for a one-month Sprint. For shorter Sprints, the event is usually shorter."
  },
  sprintRetrospective: {
    name: "Sprint Retrospective",
    description: "The purpose of the Sprint Retrospective is to plan ways to increase quality and effectiveness. The Scrum Team inspects how the last Sprint went with regards to individuals, interactions, processes, tools, and their Definition of Done.",
    examination: [
      "What went well during the Sprint?",
      "What problems did we encounter?",
      "How were those problems resolved?"
    ],
    outcome: "The Scrum Team identifies the most helpful changes to improve its effectiveness. The most impactful improvements are addressed as soon as possible, and may even be added to the Sprint Backlog for the next Sprint.",
    timebox: "The Sprint Retrospective concludes the Sprint. It is timeboxed to a maximum of three hours for a one-month Sprint. For shorter Sprints, the event is usually shorter."
  }
};
var scrumArtifacts = {
  description: "Scrum's artifacts represent work or value. They are designed to maximize transparency of key information. Each artifact contains a commitment to ensure it provides information that enhances transparency and focus against which progress can be measured.",
  artifacts: {
    productBacklog: {
      name: "Product Backlog",
      description: "The Product Backlog is an emergent, ordered list of what is needed to improve the product. It is the single source of work undertaken by the Scrum Team.",
      items: "Product Backlog items that can be completed by the Scrum Team within one Sprint are deemed ready for selection in a Sprint Planning event.",
      refinement: "Product Backlog refinement is the act of breaking down and further defining Product Backlog items into smaller more precise items.",
      commitment: {
        name: "Product Goal",
        description: "The Product Goal describes a future state of the product which can serve as a target for the Scrum Team to plan against."
      }
    },
    sprintBacklog: {
      name: "Sprint Backlog",
      description: "The Sprint Backlog is composed of the Sprint Goal (why), the set of Product Backlog items selected for the Sprint (what), as well as an actionable plan for delivering the Increment (how).",
      characteristics: "The Sprint Backlog is a plan by and for the Developers. It is a highly visible, real-time picture of the work that the Developers plan to accomplish during the Sprint in order to achieve the Sprint Goal.",
      commitment: {
        name: "Sprint Goal",
        description: "The Sprint Goal is the single objective for the Sprint. It creates coherence and focus, encouraging the Scrum Team to work together rather than on separate initiatives."
      }
    },
    increment: {
      name: "Increment",
      description: "An Increment is a concrete stepping stone toward the Product Goal. Each Increment is additive to all prior Increments and thoroughly verified, ensuring that all Increments work together. In order to provide value, the Increment must be usable.",
      multipleIncrements: "Multiple Increments may be created within a Sprint. The sum of the Increments is presented at the Sprint Review thus supporting empiricism.",
      commitment: {
        name: "Definition of Done",
        description: "The Definition of Done is a formal description of the state of the Increment when it meets the quality measures required for the product. The moment a Product Backlog item meets the Definition of Done, an Increment is born."
      }
    }
  }
};

// server/scenario-challenges.ts
var predefinedChallenges = [
  // Daily Scrum Challenges
  {
    id: "daily-status-report",
    title: "Status Report Meeting",
    description: "The Daily Scrum has devolved into a status reporting session where team members are reporting progress to you instead of planning their day and coordinating with each other.",
    eventType: "daily",
    difficulty: "beginner"
  },
  {
    id: "daily-overtime",
    title: "Overtime Issues",
    description: "Developers are consistently working overtime to meet Sprint commitments, but they're not discussing these challenges during the Daily Scrum.",
    eventType: "daily",
    difficulty: "intermediate"
  },
  {
    id: "daily-absence",
    title: "Key Member Absence",
    description: "A critical Developer is unexpectedly absent, threatening the Sprint Goal. The Scrum Team needs to replan their day but is uncertain how to proceed.",
    eventType: "daily",
    difficulty: "intermediate"
  },
  {
    id: "daily-details",
    title: "Technical Deep Dive",
    description: "The Daily Scrum consistently runs over the 15-minute timebox because Developers dive into detailed technical discussions instead of focusing on progress toward the Sprint Goal.",
    eventType: "daily",
    difficulty: "beginner"
  },
  {
    id: "daily-silence",
    title: "Silent Team Members",
    description: "Some Developers rarely speak during the Daily Scrum, while others dominate the conversation, creating an imbalance in team communication.",
    eventType: "daily",
    difficulty: "advanced"
  },
  // Sprint Planning Challenges
  {
    id: "planning-refinement",
    title: "Unrefined Backlog",
    description: "The Scrum Team is attempting Sprint Planning, but many Product Backlog items are poorly defined, lacking clarity and estimation.",
    eventType: "planning",
    difficulty: "beginner"
  },
  {
    id: "planning-capacity",
    title: "Capacity Planning Issues",
    description: "The Product Owner is pushing the Developers to commit to more work than their historical velocity suggests they can accomplish.",
    eventType: "planning",
    difficulty: "intermediate"
  },
  {
    id: "planning-dependencies",
    title: "External Dependencies",
    description: "Several high-priority Product Backlog items have external dependencies on other teams or vendors, which may impact the Scrum Team's ability to meet the Sprint Goal.",
    eventType: "planning",
    difficulty: "advanced"
  },
  {
    id: "planning-scope",
    title: "Unclear Sprint Goal",
    description: "The Scrum Team is struggling to establish a clear, focused Sprint Goal that provides coherence to their work.",
    eventType: "planning",
    difficulty: "intermediate"
  },
  {
    id: "planning-technical-debt",
    title: "Technical Debt Dilemma",
    description: "The Developers have accumulated significant technical debt that is slowing development, but the Product Owner is reluctant to allocate Sprint capacity to address it.",
    eventType: "planning",
    difficulty: "advanced"
  },
  // Sprint Review Challenges
  {
    id: "review-incomplete",
    title: "Incomplete Increment",
    description: "The Scrum Team has not completed all Sprint Backlog items and is unsure how to approach the Sprint Review when the Increment is incomplete.",
    eventType: "review",
    difficulty: "beginner"
  },
  {
    id: "review-stakeholder",
    title: "Stakeholder Criticism",
    description: "A key stakeholder is expressing strong disappointment with the Increment during the Sprint Review, creating tension and defensiveness.",
    eventType: "review",
    difficulty: "advanced"
  },
  {
    id: "review-feedback",
    title: "Lack of Feedback",
    description: "During the Sprint Review, stakeholders are passively observing rather than engaging with the Increment, providing little actionable feedback.",
    eventType: "review",
    difficulty: "intermediate"
  },
  {
    id: "review-scope-change",
    title: "Scope Change Requests",
    description: "Stakeholders are requesting significant feature changes during the Sprint Review, rather than focusing on inspecting what was completed.",
    eventType: "review",
    difficulty: "intermediate"
  },
  {
    id: "review-business-value",
    title: "Business Value Concerns",
    description: "The Product Owner is struggling to articulate how the completed Increment delivers business value, making it difficult to adjust the Product Backlog effectively.",
    eventType: "review",
    difficulty: "advanced"
  },
  // Sprint Retrospective Challenges
  {
    id: "retro-silence",
    title: "Silence and Disengagement",
    description: "The Scrum Team is disengaged during the Sprint Retrospective, providing minimal input on what went well or what could be improved.",
    eventType: "retro",
    difficulty: "beginner"
  },
  {
    id: "retro-blame",
    title: "Blame Game",
    description: "The Retrospective has turned into a blame session, with Developers pointing fingers at each other rather than focusing on systemic improvements.",
    eventType: "retro",
    difficulty: "advanced"
  },
  {
    id: "retro-actionable",
    title: "Non-Actionable Items",
    description: "While the Scrum Team identifies issues during the Retrospective, they struggle to create actionable, measurable improvement plans.",
    eventType: "retro",
    difficulty: "intermediate"
  },
  {
    id: "retro-repetition",
    title: "Repeated Issues",
    description: "The same problems appear Sprint after Sprint in the Retrospective, suggesting that previous improvement plans are not being implemented effectively.",
    eventType: "retro",
    difficulty: "intermediate"
  },
  {
    id: "retro-management",
    title: "Management Interference",
    description: "A senior manager has asked to attend the Sprint Retrospective to 'help address team problems,' potentially inhibiting the team's psychological safety.",
    eventType: "retro",
    difficulty: "advanced"
  }
];
function getScenarioChallenges(eventType) {
  return predefinedChallenges.filter((challenge) => challenge.eventType === eventType);
}
function getScenarioChallengeById(scenarioId) {
  return predefinedChallenges.find((challenge) => challenge.id === scenarioId);
}

// server/storage.ts
var MemStorage = class {
  simulationInfos;
  messages;
  messageCurrentId;
  simulationInfoCurrentId;
  scenarioChallenges;
  constructor() {
    this.simulationInfos = /* @__PURE__ */ new Map();
    this.messages = /* @__PURE__ */ new Map();
    this.messageCurrentId = 1;
    this.simulationInfoCurrentId = 1;
    this.scenarioChallenges = /* @__PURE__ */ new Map();
    this.initializeSimulationData();
  }
  initializeSimulationData() {
    const events = ["daily", "planning", "review", "retro"];
    const teamMembers = [
      { name: "Alex", role: "Product Owner", status: "available" },
      { name: "Taylor", role: "Developer", status: "available" },
      { name: "Jordan", role: "Developer", status: "available" },
      { name: "Morgan", role: "Developer", status: "available" },
      // Designer is a skill, not a Scrum role
      { name: "Casey", role: "Developer", status: "unavailable" }
    ];
    const sprintDetails = {
      number: 7,
      duration: "2 weeks",
      previousVelocity: 34
    };
    const roleDescriptions = {
      daily: `In this simulation, you are the ${scrumTeam.roles.scrumMaster.name}. Your primary accountability is to ensure the Daily Scrum happens, is effective, and stays within the ${scrumEvents.dailyScrum.timebox} timebox. ${scrumEvents.dailyScrum.description} ${scrumEvents.dailyScrum.structure} I (the AI) will provide coaching and simulate team responses.`,
      planning: `In this simulation, you are the ${scrumTeam.roles.scrumMaster.name}. You facilitate the Sprint Planning which ${scrumEvents.sprintPlanning.description} The event is timeboxed to ${scrumEvents.sprintPlanning.timebox}. You help the team address: ${scrumEvents.sprintPlanning.topics.join(", ")}. I (the AI) will provide coaching and simulate team responses.`,
      review: `In this simulation, you are the ${scrumTeam.roles.scrumMaster.name}. You facilitate the Sprint Review where ${scrumEvents.sprintReview.description} ${scrumEvents.sprintReview.nature} The event is timeboxed to ${scrumEvents.sprintReview.timebox}. I (the AI) will provide coaching and simulate team and stakeholder responses.`,
      retro: `In this simulation, you are the ${scrumTeam.roles.scrumMaster.name}. You facilitate the Sprint Retrospective where ${scrumEvents.sprintRetrospective.description} The team examines: ${scrumEvents.sprintRetrospective.examination.join(", ")}. The event is timeboxed to ${scrumEvents.sprintRetrospective.timebox}. I (the AI) will provide coaching and simulate team responses.`
    };
    events.forEach((eventType) => {
      const id = this.simulationInfoCurrentId++;
      const info = {
        id,
        eventType,
        teamMembers,
        sprintDetails,
        roleDescription: roleDescriptions[eventType],
        scenarioType: null,
        scenarioChallenge: null,
        customScenario: null
      };
      this.simulationInfos.set(eventType, info);
      const initialMessages = [{
        id: this.messageCurrentId++,
        eventType,
        type: "ai",
        content: this.getWelcomeMessage(eventType),
        timestamp: /* @__PURE__ */ new Date()
      }];
      this.messages.set(eventType, initialMessages);
    });
  }
  getWelcomeMessage(eventType) {
    switch (eventType) {
      case "daily":
        return `Welcome to the ${scrumEvents.dailyScrum.name} simulation. As the Scrum Master, you're about to facilitate this ${scrumEvents.dailyScrum.timebox} event. According to the Scrum Guide, ${scrumEvents.dailyScrum.description}

The purpose is to inspect progress toward the ${scrumArtifacts.artifacts.sprintBacklog.commitment.name} and adapt the Sprint Backlog as necessary.

How would you start this Daily Scrum as the Scrum Master?`;
      case "planning":
        return `Welcome to the ${scrumEvents.sprintPlanning.name} simulation. As the Scrum Master, you'll be facilitating this ${scrumEvents.sprintPlanning.timebox} event. According to the Scrum Guide, ${scrumEvents.sprintPlanning.description}

The key topics to address are: ${scrumEvents.sprintPlanning.topics[0]}, ${scrumEvents.sprintPlanning.topics[1]}, and ${scrumEvents.sprintPlanning.topics[2]}.

How would you begin facilitating this Sprint Planning session?`;
      case "review":
        return `Welcome to the ${scrumEvents.sprintReview.name} simulation. As the Scrum Master, you'll be facilitating this ${scrumEvents.sprintReview.timebox} event. According to the Scrum Guide, ${scrumEvents.sprintReview.description}

Remember, this is a working session to inspect the ${scrumArtifacts.artifacts.increment.name} and adapt the ${scrumArtifacts.artifacts.productBacklog.name}.

How would you start this Sprint Review as the Scrum Master?`;
      case "retro":
        return `Welcome to the ${scrumEvents.sprintRetrospective.name} simulation. As the Scrum Master, you'll be facilitating this ${scrumEvents.sprintRetrospective.timebox} event. According to the Scrum Guide, ${scrumEvents.sprintRetrospective.description}

This is an opportunity for the Scrum Team to identify improvements for processes, interactions, and tools.

How would you begin facilitating this Retrospective session?`;
      default:
        return `Welcome to this Scrum event simulation. As the Scrum Master, how would you like to facilitate this session?`;
    }
  }
  async getSimulationInfo(eventType) {
    try {
      const info = this.simulationInfos.get(eventType);
      if (!info) {
        console.error(`No simulation info found for event type: ${eventType}`);
        throw new Error(`No simulation info found for event type: ${eventType}`);
      }
      return info;
    } catch (error) {
      console.error("Error getting simulation info:", error);
      throw error;
    }
  }
  async getMessages(eventType) {
    try {
      return this.messages.get(eventType) || [];
    } catch (error) {
      console.error("Error getting messages:", error);
      return [];
    }
  }
  async addMessage(insertMessage) {
    try {
      const id = this.messageCurrentId++;
      const timestamp = /* @__PURE__ */ new Date();
      const message = {
        ...insertMessage,
        id,
        timestamp
      };
      const eventMessages = this.messages.get(insertMessage.eventType) || [];
      eventMessages.push(message);
      this.messages.set(insertMessage.eventType, eventMessages);
      return message;
    } catch (error) {
      console.error("Error adding message:", error);
      throw error;
    }
  }
  async getScenarioChallenges(eventType) {
    try {
      return getScenarioChallenges(eventType);
    } catch (error) {
      console.error("Error getting scenario challenges:", error);
      return [];
    }
  }
  async startScenario(eventType, scenarioType, scenarioId, customScenario) {
    try {
      const currentInfo = await this.getSimulationInfo(eventType);
      const updatedInfo = {
        ...currentInfo,
        scenarioType
      };
      if (scenarioType === "predefined" && scenarioId) {
        const challenge = getScenarioChallengeById(scenarioId);
        if (!challenge) {
          throw new Error(`Scenario challenge not found: ${scenarioId}`);
        }
        updatedInfo.scenarioChallenge = challenge;
      }
      if (scenarioType === "custom" && customScenario) {
        updatedInfo.customScenario = customScenario;
      }
      this.simulationInfos.set(eventType, updatedInfo);
      const initialMessages = [{
        id: this.messageCurrentId++,
        eventType,
        type: "ai",
        content: this.getScenarioWelcomeMessage(eventType, scenarioType, updatedInfo),
        timestamp: /* @__PURE__ */ new Date()
      }];
      this.messages.set(eventType, initialMessages);
      return updatedInfo;
    } catch (error) {
      console.error("Error starting scenario:", error);
      throw error;
    }
  }
  getScenarioWelcomeMessage(eventType, scenarioType, simulationInfo) {
    if (scenarioType === "predefined" && simulationInfo.scenarioChallenge) {
      const challenge = simulationInfo.scenarioChallenge;
      return `Welcome to the "${challenge.title}" scenario for the ${eventType} Scrum event.

${challenge.description}

You are the Scrum Master in this scenario. How would you address this challenge? I'll provide coaching and guidance as you work through it.`;
    } else if (scenarioType === "custom" && simulationInfo.customScenario) {
      return `Welcome to your custom scenario for the ${eventType} Scrum event. Here's the situation you've described:

${simulationInfo.customScenario}

You are the Scrum Master in this scenario. How would you approach this situation? I'll act as your AI coach, offering guidance and simulating team responses as needed.`;
    } else {
      return this.getWelcomeMessage(eventType);
    }
  }
};
var storage = new MemStorage();

// server/routes.ts
import { z } from "zod";
var OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY || "";
console.log("OpenRouter API Key available:", !!OPENROUTER_API_KEY);
var icebreakerSchema = z.object({
  vibe: z.enum(["random", "funny", "deep", "creative"])
});
var messageSchema = z.object({
  eventType: z.enum(["daily", "planning", "review", "retro"]),
  content: z.string().min(1)
});
var startScenarioSchema = z.object({
  eventType: z.enum(["daily", "planning", "review", "retro"]),
  scenarioType: z.enum(["predefined", "custom"]),
  scenarioId: z.string().optional(),
  customScenario: z.string().optional()
}).refine((data) => {
  if (data.scenarioType === "predefined") {
    return !!data.scenarioId;
  }
  if (data.scenarioType === "custom") {
    return !!data.customScenario;
  }
  return false;
}, {
  message: "scenarioId is required for predefined scenarios, customScenario is required for custom scenarios"
});
async function registerRoutes(app2) {
  const httpServer = createServer(app2);
  app2.post("/api/icebreaker", async (req, res) => {
    try {
      const { vibe } = icebreakerSchema.parse(req.body);
      console.log(`Generating icebreaker with vibe: ${vibe}`);
      if (!OPENROUTER_API_KEY) {
        console.log("No OpenRouter API key available, returning fallback response");
        return res.json({
          question: "What's one way your team demonstrated a Scrum value in the last Sprint?"
        });
      }
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${OPENROUTER_API_KEY}`,
          "HTTP-Referer": "https://kairos-coach.com"
        },
        body: JSON.stringify({
          model: "gryphe/mythomax-l2-13b",
          messages: [
            {
              role: "system",
              content: `You are an expert Scrum Master assistant that generates engaging icebreaker questions that promote Agile principles and Scrum values.

Scrum Values to embody:
${scrumValues.values.map((value) => `- ${value}: ${value}`).join("\n")}

${scrumValues.description}

Scrum Team Structure:
${scrumTeam.composition}
${scrumTeam.characteristics.map((char) => `- ${char}`).join("\n")}
`
            },
            {
              role: "user",
              content: `Generate a ${vibe} icebreaker question for a Scrum Team meeting. The question should be:
- Thought-provoking and concise (max 25 words)
- Designed to foster transparency, inspection, and adaptation
- Supportive of building cross-functional collaboration and self-management
- Aligned with Scrum values (commitment, courage, focus, openness, respect)
- ${vibe === "funny" ? "Lighthearted and humorous" : vibe === "deep" ? "Reflective and meaningful" : vibe === "creative" ? "Imaginative and innovative" : "Balanced and engaging"}

Reply with ONLY the question text.`
            }
          ],
          max_tokens: 150
        })
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Failed to generate icebreaker question");
      }
      const data = await response.json();
      const question = data.choices[0]?.message?.content?.trim() || "What's something unexpected you learned recently that changed your perspective?";
      return res.json({ question });
    } catch (error) {
      console.error("Error generating icebreaker:", error);
      if (error instanceof Error) {
        console.error("Error details:", error.message, error.stack);
      } else if (error instanceof Response) {
        console.error("Error status:", error.status, error.statusText);
        try {
          const errorData = await error.json();
          console.error("API error response:", errorData);
        } catch (e) {
          console.error("Could not parse error response");
        }
      }
      return res.status(500).json({
        message: error instanceof Error ? error.message : "Error generating icebreaker question. Check server logs for details."
      });
    }
  });
  app2.get("/api/simulation-info", async (req, res) => {
    try {
      const eventType = req.query.eventType;
      if (!["daily", "planning", "review", "retro"].includes(eventType)) {
        return res.status(400).json({ message: "Invalid event type" });
      }
      const simulationInfo = await storage.getSimulationInfo(eventType);
      return res.json(simulationInfo);
    } catch (error) {
      console.error("Error fetching simulation info:", error);
      return res.status(500).json({
        message: error instanceof Error ? error.message : "Error fetching simulation info"
      });
    }
  });
  app2.get("/api/messages", async (req, res) => {
    try {
      const eventType = req.query.eventType;
      if (!["daily", "planning", "review", "retro"].includes(eventType)) {
        return res.status(400).json({ message: "Invalid event type" });
      }
      const messages = await storage.getMessages(eventType);
      return res.json(messages);
    } catch (error) {
      console.error("Error fetching messages:", error);
      return res.status(500).json({
        message: error instanceof Error ? error.message : "Error fetching messages"
      });
    }
  });
  app2.post("/api/messages", async (req, res) => {
    try {
      const { eventType, content } = messageSchema.parse(req.body);
      console.log(`Sending message in ${eventType} event: ${content.substring(0, 30)}...`);
      const userMessage = await storage.addMessage({
        type: "user",
        content,
        eventType
      });
      const simulationInfo = await storage.getSimulationInfo(eventType);
      const previousMessages = await storage.getMessages(eventType);
      const messageHistory = previousMessages.map((msg) => ({
        role: msg.type === "user" ? "user" : "assistant",
        content: msg.content
      }));
      const eventContext = {
        daily: scrumEvents.dailyScrum.description,
        planning: scrumEvents.sprintPlanning.description,
        review: scrumEvents.sprintReview.description,
        retro: scrumEvents.sprintRetrospective.description
      };
      const typedSimulationInfo = simulationInfo;
      const systemMessage = `
You are an AI Coach supporting the user, who is a Scrum Master facilitating a ${eventType} Scrum event.

About this scenario:
${eventContext[eventType]}

Team context:
- Sprint #${typedSimulationInfo.sprintDetails.number}
- Previous velocity: ${typedSimulationInfo.sprintDetails.previousVelocity} points
- Team members: ${typedSimulationInfo.teamMembers.map((m) => `${m.name} (${m.role})`).join(", ")}

YOUR ROLE: You are NOT the Scrum Master. You are an AI Coach supporting the user, who IS the Scrum Master.

As an AI Coach, you should:
1. Provide guidance and advice to help the user (Scrum Master) facilitate the event effectively
2. Ask powerful coaching questions that help the Scrum Master reflect and improve
3. Share relevant knowledge from the Scrum Guide 2020 and Agile Manifesto when appropriate
4. Simulate team member responses when the Scrum Master interacts with the team
5. Provide feedback on the Scrum Master's approach based on Scrum principles

Agile Manifesto Values:
- Individuals and interactions over processes and tools
- Working software over comprehensive documentation 
- Customer collaboration over contract negotiation
- Responding to change over following a plan

The Scrum Values that should be reinforced:
${scrumValues.values.map((value) => `- ${value}`).join("\n")}

Additional requirements:
- Keep responses thoughtful but reasonably concise (up to 6-7 sentences) and focused on the event at hand
- Be positive and solution-oriented
- Focus on empiricism: transparency, inspection, and adaptation
- Encourage self-management and cross-functionality
- Make it clear that the USER is the Scrum Master and YOU are the coach/facilitator/simulator
`;
      if (!OPENROUTER_API_KEY) {
        console.log("No OpenRouter API key available, returning fallback response");
        let aiResponse2 = "";
        switch (eventType) {
          case "daily":
            aiResponse2 = 'As the Scrum Master, you might want to consider how the team is progressing toward the Sprint Goal. A powerful question you could ask might be: "What impediments are preventing us from achieving our Sprint Goal?" Remember, the Daily Scrum is for the Developers to inspect progress and adapt their plan.';
            break;
          case "planning":
            aiResponse2 = "In your role as Scrum Master, you're facilitating this Planning session. Have you considered asking the team how confident they feel about the Definition of Done for these items? The Product Owner seems concerned about the scope - how might you help balance ambition with realism?";
            break;
          case "review":
            aiResponse2 = "As you facilitate this Sprint Review, consider how you might help the team gather meaningful feedback from stakeholders. What questions could you ask to ensure the team understands how their work impacts the product's value? Remember the Review is an opportunity for inspection and adaptation of the Product.";
            break;
          case "retro":
            aiResponse2 = 'In facilitating this Retrospective, you might want to focus on creating a safe space for the team to reflect honestly. Consider asking: "What one change could make us more effective as a team?" Remember that the Retrospective is about identifying improvements, not just listing problems.';
            break;
          default:
            aiResponse2 = "As the Scrum Master facilitating this event, your focus on empiricism is key. Consider how you might help the team inspect what's happening and adapt accordingly. What powerful questions could you ask that would help the team self-organize around this challenge?";
        }
        const aiMessage2 = await storage.addMessage({
          type: "ai",
          content: aiResponse2,
          eventType
        });
        return res.json({ success: true, message: aiMessage2 });
      }
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${OPENROUTER_API_KEY}`,
          "HTTP-Referer": "https://kairos-coach.com"
        },
        body: JSON.stringify({
          model: "anthropic/claude-3-haiku",
          messages: [
            { role: "system", content: systemMessage },
            ...messageHistory,
            { role: "user", content }
          ],
          max_tokens: 800
        })
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Failed to generate AI response");
      }
      const data = await response.json();
      const aiResponse = data.choices[0]?.message?.content?.trim();
      const aiMessage = await storage.addMessage({
        type: "ai",
        content: aiResponse,
        eventType
      });
      return res.json({ success: true, message: aiMessage });
    } catch (error) {
      console.error("Error sending message:", error);
      if (error instanceof Error) {
        console.error("Error details:", error.message, error.stack);
      } else if (error instanceof Response) {
        console.error("Error status:", error.status, error.statusText);
        try {
          const errorData = await error.json();
          console.error("API error response:", errorData);
        } catch (e) {
          console.error("Could not parse error response");
        }
      }
      return res.status(500).json({
        message: error instanceof Error ? error.message : "Error processing message. Check server logs for details."
      });
    }
  });
  app2.get("/api/scenario-challenges", async (req, res) => {
    try {
      const eventType = req.query.eventType;
      if (!["daily", "planning", "review", "retro"].includes(eventType)) {
        return res.status(400).json({ message: "Invalid event type" });
      }
      const challenges = await storage.getScenarioChallenges(eventType);
      return res.json(challenges);
    } catch (error) {
      console.error("Error fetching scenario challenges:", error);
      return res.status(500).json({
        message: error instanceof Error ? error.message : "Error fetching scenario challenges"
      });
    }
  });
  app2.post("/api/start-scenario", async (req, res) => {
    try {
      const { eventType, scenarioType, scenarioId, customScenario } = startScenarioSchema.parse(req.body);
      console.log(`Starting ${scenarioType} scenario for ${eventType} event`);
      const updatedSimulationInfo = await storage.startScenario(
        eventType,
        scenarioType,
        scenarioId,
        customScenario
      );
      return res.json(updatedSimulationInfo);
    } catch (error) {
      console.error("Error starting scenario:", error);
      return res.status(500).json({
        message: error instanceof Error ? error.message : "Error starting scenario"
      });
    }
  });
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2, { dirname as dirname2 } from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath } from "url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = dirname(__filename);
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "client", "src"),
      "@shared": path.resolve(__dirname, "shared"),
      "@assets": path.resolve(__dirname, "attached_assets")
    }
  },
  root: path.resolve(__dirname, "client"),
  build: {
    outDir: path.resolve(__dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var __filename2 = fileURLToPath2(import.meta.url);
var __dirname2 = dirname2(__filename2);
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        __dirname2,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(__dirname2, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = 5e3;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();